/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file SimplifiedMesh.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2020/02/18
 *
 * Implementation of inline methods defined in SimplifiedMesh.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include "DGtal/shapes/MeshHelpers.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealPointIterator, typename FaceIterator>
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
SimplifiedMesh( RealPointIterator itPos, RealPointIterator itPosEnd,
                    FaceIterator itFace, FaceIterator itFaceEnd )
{
  bool ok = init( itPos, itPosEnd, itFace, itFaceEnd );
  if ( !ok ) clear();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealPointIterator, typename FaceIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
init( RealPointIterator itPos, RealPointIterator itPosEnd,
      FaceIterator itFace, FaceIterator itFaceEnd )
{
  clear();
  myPositions = std::vector< RealPoint >( itPos, itPosEnd );
  myIncidentFaces.resize( myPositions.size() );
  Index f = 0; // current face index
  bool ok = true;
  for ( ; ok && itFace != itFaceEnd; ++itFace, ++f )
    {
      Vertices f_vtcs;
      for ( auto it = itFace->begin(), itE = itFace->end(); it != itE; ++it )
	{
	  Index vtx = *it;
	  if ( vtx >= myIncidentFaces.size() )
	    trace.warning() << "[SimplifiedMesh::init] Invalid vtx "
			    << vtx << " at face " << f << std::endl;
	  else
	    {
	      myIncidentFaces[ vtx ].push_back( f );
	      f_vtcs.push_back( vtx );
	    }
	}
      myIncidentVertices.push_back( f_vtcs );
    }
  return ok;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
clear()
{
  myIncidentVertices.clear();
  myIncidentFaces.clear();
  myPositions.clear();
  myVertexNormals.clear();
  myFaceNormals.clear();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealVectorIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
setVertexNormals( RealVectorIterator itN, RealVectorIterator itNEnd )
{
  myVertexNormals = std::vector< RealVector >( itN, itNEnd );
  return myVertexNormals.size() == myPositions.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealVectorIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
setFaceNormals( RealVectorIterator itN, RealVectorIterator itNEnd )
{
  myFaceNormals = std::vector< RealVector >( itN, itNEnd );
  return myFaceNormals.size() == myIncidentVertices.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFaceNormalsFromPositions()
{
  myFaceNormals.resize( myIncidentVertices.size() );
  Index f = 0;
  for ( auto face : myIncidentVertices )
    {
      RealPoint  p; // barycenter
      RealVector n; // normal
      // compute barycenter
      for ( auto idx : face ) p += myPositions[ idx ];
      p /= face.size();
      // compute normal as sum of triangle normal vectors.
      for ( Index i = 0; i < face.size(); ++i )
	{
	  const Index  j = face[ i ];
	  const Index nj = face[ (i+1) % face.size() ];
	  n += ( myPositions[ j ] - p ).crossProduct( myPositions[ nj ] - p );
	}
      myFaceNormals[ f++ ] = n.getNormalized();
    }
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFaceNormalsFromVertexNormals()
{
  if ( myVertexNormals.empty() ) return;
  myFaceNormals.resize( myIncidentVertices.size() );
  Index f = 0;
  for ( auto face : myIncidentVertices )
    {
      RealVector n; // normal
      for ( auto idx : face ) n += myVertexNormals[ idx ];
      myFaceNormals[ f++ ] = n.getNormalized();
    }
}
//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeVertexNormalsFromFaceNormals()
{
  if ( myFaceNormals.empty() ) return;
  myVertexNormals.resize( myIncidentFaces.size() );
  Index v = 0;
  for ( auto vertex : myIncidentFaces )
    {
      RealVector n; // normal
      for ( auto idx : vertex ) n += myFaceNormals[ idx ];
      myVertexNormals[ v++ ] = n.getNormalized();
    }
}



///////////////////////////////////////////////////////////////////////////////
// Interface - public :

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
selfDisplay ( std::ostream & out ) const
{
  out << "[SimplifiedMesh" << ( isValid() ? " (OK)" : " (KO)" )
      << " #V=" << myPositions.size()
      << " #VN=" << myVertexNormals.size()
      << " #F=" << myIncidentVertices.size()
      << " #FN=" << myFaceNormals.size()
      << "]";
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
isValid() const
{
  return myPositions.size() == myIncidentFaces.size()
    && ( myVertexNormals.size() == 0
	 || ( myVertexNormals.size() == myPositions.size() ) )
    && ( myFaceNormals.size() == 0
	 || ( myFaceNormals.size() == myIncidentVertices.size() ) );
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
std::ostream&
DGtal::operator<< ( std::ostream & out, 
                    const SimplifiedMesh<TRealPoint, TRealVector> & object )
{
  object.selfDisplay( out );
  return out;
}


///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
verifyIndices( const std::vector< Index > indices )
{
  std::set<Index> sindices( indices.begin(), indices.end() );
  return sindices.size() == indices.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
std::vector< std::string > 
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
split( const std::string& str, char delim )
{
  std::stringstream ss(str);
  std::string token;
  std::vector< std::string > cont;
  while ( std::getline( ss, token, delim ) ) cont.push_back(token);
  return cont;
}    

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
readOBJ( std::istream & input, SimplifiedMesh & smesh )
{
  std::vector<RealPoint>  vertices;
  std::vector<RealVector> normals;
  std::vector< std::vector< Index > > faces;
  std::vector< std::vector< Index > > faces_normals_idx;
  std::string linestr;
  std::string keyword;
  std::string indices;
  RealPoint  p;
  RealVector n;
  std::getline( input, linestr );
  Index l = 0;
  for ( ; input.good() && ! input.eof(); std::getline( input, linestr ), l++ )
    {
      if ( linestr.empty() ) continue; // skip empty line
      if ( linestr[0] == '#' ) continue; // skip comment line
      std::istringstream lineinput( linestr );
      std::operator>>( lineinput, keyword ); // lineinput >> keyword;
      if ( keyword == "v" ) {
	lineinput >> p[ 0 ] >> p[ 1 ] >> p[ 2 ];
	// std::cout << "[" << l << "] v " << p << std::endl;
	vertices.push_back( p );
      } else if ( keyword == "vn" ) {
	lineinput >> n[ 0 ] >> n[ 1 ] >> n[ 2 ];
	normals.push_back( n );
      } else if ( keyword == "f" ) {
	std::vector< Index > face, face_normals;
	while ( ! lineinput.eof() ) {
          std::operator>>( lineinput, indices ); // lineinput >> indices;
	  if ( indices.empty() ) break;
	  auto vtxinfo = split( indices, '/' );
	  if ( vtxinfo.size() == 0 ) break;
	  Index v  = std::stoi( vtxinfo[ 0 ] );
	  Index vn = vtxinfo.size() >= 3 ? std::stoi( vtxinfo[ 2 ] ) : v;
	  face.push_back( v - 1 );
	  face_normals.push_back( vn - 1 );
	  indices = "";
	}
	if ( ! face.empty() && verifyIndices( face ) )
	  {
	    faces.push_back( face );
	    faces_normals_idx.push_back( face_normals );
	  }
      }
      // Weird: necessary to clear them.
      keyword = ""; linestr = "";
    } // while ( ! input.eof() )
  // Creating SimplifiedMesh
  trace.info() << "[SimplifiedMeshReader::readOBJ] Read"
	       << " #lines=" << l
	       << " #V=" << vertices.size()
	       << " #VN=" << normals.size()
	       << " #F=" << faces.size() << std::endl;
  if ( input.bad() )
    trace.warning() << "[SimplifiedMeshReader::readOBJ] Some I/O error occured."
		    << " Proceeding but the mesh may be damaged." << std::endl;
  bool ok = smesh.init( vertices.begin(), vertices.end(),
			faces.begin(), faces.end() );
  if ( ! ok )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error initializing mesh." << std::endl;
  if ( ( ! normals.empty() ) && ( normals.size() == vertices.size() ) )
    { // Build vertex normal map
      bool ok_vtx_normals = smesh.setVertexNormals( normals.begin(), normals.end() );
      if ( ! ok_vtx_normals )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error setting vertex normals." << std::endl;
      ok = ok && ok_vtx_normals;
    }
  if ( ! normals.empty() )
    { // Build face normal map
      std::vector< RealVector > faces_normals;
      Index i = 0;
      for ( auto face_n_indices : faces_normals_idx )
	{ 
	  RealVector n;
	  for ( auto k : face_n_indices ) n += normals[ k ];
	  n /= face_n_indices.size();
	  faces_normals.push_back( n );
	}
      bool ok_face_normals = smesh.setFaceNormals( faces_normals.begin(),
						   faces_normals.end() );
      if ( ! ok_face_normals )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error setting face normals." << std::endl;
      ok = ok && ok_face_normals;
    }
  return ( ! input.bad() ) && ok;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshWriter<TRealPoint, TRealVector>::
writeOBJ( std::ostream & output, const SimplifiedMesh & smesh )
{
  output << "# OBJ format" << std::endl;
  output << "# DGtal::SimplifiedMeshWriter::writeOBJ" << std::endl;
  output << "o anObject" << std::endl;
  for ( auto v : smesh.positions() )
    output << "v " << v[ 0 ] << " " << v[ 1 ] << " " << v[ 2 ] << std::endl;
  output << "# " << smesh.positions().size() << " vertices" << std::endl;
  if ( ! smesh.vertexNormals().empty() )
    {
      for ( auto vn : smesh.vertexNormals() )
        output << "vn " << vn[ 0 ] << " " << vn[ 1 ] << " " << vn[ 2 ] << std::endl;
      output << "# " << smesh.vertexNormals().size() << " normal vectors" << std::endl;
    }
  for ( auto f : smesh.incidentVertices() )
    {
      output << "f";
      for ( auto v : f ) output << " " << (v+1);
      output << std::endl;
    }
  output << "# " << smesh.incidentVertices().size() << " faces" << std::endl;
  return output.good();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshWriter<TRealPoint, TRealVector>::
writeOBJ( std::string            objfile,
          const SimplifiedMesh & smesh, 
          const Colors&          diffuse_colors,
          const Color&           ambient_color,
          const Color&           diffuse_color,
          const Color&           specular_color )
{
  std::string mtlfile;
  auto lastindex = objfile.find_last_of(".");
  if ( lastindex == std::string::npos )
    {
      mtlfile  = objfile + ".mtl";
      objfile  = objfile + ".obj";
    }
  else
    {
      mtlfile  = objfile.substr(0, lastindex) + ".mtl"; 
    }
  std::ofstream output_obj( objfile.c_str() );
  output_obj << "#  OBJ format" << std::endl;
  output_obj << "# DGtal::SimplifiedMeshWriter::writeOBJ" << std::endl;
  output_obj << "o anObject" << std::endl;
  // remove directory to write material
  auto indexpath = objfile.find_last_of("/");
  output_obj << "mtllib " << mtlfile.substr(indexpath+1) << std::endl;
  std::ofstream output_mtl( mtlfile.c_str() );
  output_mtl << "#  MTL format"<< std::endl;
  output_mtl << "# generated from SimplifiedMeshWriter from the DGTal library"<< std::endl;
  // Write positions
  for ( auto v : smesh.positions() )
    output_obj << "v " << v[ 0 ] << " " << v[ 1 ] << " " << v[ 2 ] << std::endl;
  output_obj << "# " << smesh.positions().size() << " vertices" << std::endl;
  // Write vertex normals
  if ( ! smesh.vertexNormals().empty() )
    {
      for ( auto vn : smesh.vertexNormals() )
        output_obj << "vn " << vn[ 0 ] << " " << vn[ 1 ] << " " << vn[ 2 ] << std::endl;
      output_obj << "# " << smesh.vertexNormals().size() << " normal vectors" << std::endl;
    }
  // Taking care of materials
  bool  has_material = ( smesh.nbFaces() == diffuse_colors.size() );
  Index idxMaterial = 0;
  std::map<Color, Index > mapMaterial;
  if ( has_material )
    {
      for ( Index f = 0; f < diffuse_colors.size(); ++f )
        {
          Color c = diffuse_colors[ f ];
          if ( mapMaterial.count( c ) == 0 )
            {
              MeshHelpers::exportMTLNewMaterial
                ( output_mtl, idxMaterial, ambient_color, c, specular_color );
              mapMaterial[ c ] = idxMaterial++;
            }
        }
    }
  else
    {
      MeshHelpers::exportMTLNewMaterial
        ( output_mtl, idxMaterial, ambient_color, diffuse_color, specular_color );
    }
  // Write faces with material(s)
  Index idx_f = 0;
  for ( auto f : smesh.incidentVertices() )
    {
      output_obj << "usemtl material_"
                 << ( has_material ? mapMaterial[ diffuse_colors[ idx_f ] ] : idxMaterial )
                 << std::endl; 
      output_obj << "f";
      for ( auto v : f )
        if ( smesh.vertexNormals().empty() )
          output_obj << " " << (v+1);
        else
          output_obj << " " << (v+1) << "//" << (v+1);
      output_obj << std::endl;
      idx_f++;
    }
  output_obj << "# " << smesh.incidentVertices().size() << " faces" << std::endl;
  output_mtl.close();
  return output_obj.good();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
