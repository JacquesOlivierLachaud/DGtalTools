/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file SimplifiedMesh.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2020/02/18
 *
 * Implementation of inline methods defined in SimplifiedMesh.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <limits>
#include "DGtal/shapes/MeshHelpers.h"
#include "DGtal/helpers/Shortcuts.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealPointIterator, typename FaceIterator>
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
SimplifiedMesh( RealPointIterator itPos, RealPointIterator itPosEnd,
                    FaceIterator itFace, FaceIterator itFaceEnd )
{
  bool ok = init( itPos, itPosEnd, itFace, itFaceEnd );
  if ( !ok ) clear();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealPointIterator, typename FaceIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
init( RealPointIterator itPos, RealPointIterator itPosEnd,
      FaceIterator itFace, FaceIterator itFaceEnd )
{
  clear();
  myPositions = std::vector< RealPoint >( itPos, itPosEnd );
  myIncidentFaces.resize( myPositions.size() );
  Index f = 0; // current face index
  bool ok = true;
  for ( ; ok && itFace != itFaceEnd; ++itFace, ++f )
    {
      Vertices f_vtcs;
      for ( auto it = itFace->begin(), itE = itFace->end(); it != itE; ++it )
	{
	  Index vtx = *it;
	  if ( vtx >= myIncidentFaces.size() )
	    trace.warning() << "[SimplifiedMesh::init] Invalid vtx "
			    << vtx << " at face " << f << std::endl;
	  else
	    {
	      myIncidentFaces[ vtx ].push_back( f );
	      f_vtcs.push_back( vtx );
	    }
	}
      myIncidentVertices.push_back( f_vtcs );
    }
  computeNeighbors();
  computeEdges();
  return ok;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
clear()
{
  myIncidentVertices.clear();
  myIncidentFaces.clear();
  myPositions.clear();
  myVertexNormals.clear();
  myFaceNormals.clear();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealVectorIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
setVertexNormals( RealVectorIterator itN, RealVectorIterator itNEnd )
{
  myVertexNormals = std::vector< RealVector >( itN, itNEnd );
  return myVertexNormals.size() == myPositions.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename RealVectorIterator>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
setFaceNormals( RealVectorIterator itN, RealVectorIterator itNEnd )
{
  myFaceNormals = std::vector< RealVector >( itN, itNEnd );
  return myFaceNormals.size() == myIncidentVertices.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFaceNormalsFromPositions()
{
  myFaceNormals.resize( myIncidentVertices.size() );
  Index f = 0;
  for ( auto face : myIncidentVertices )
    {
      RealPoint  p; // barycenter
      RealVector n; // normal
      // compute barycenter
      for ( auto idx : face ) p += myPositions[ idx ];
      p /= face.size();
      // compute normal as sum of triangle normal vectors.
      for ( Index i = 0; i < face.size(); ++i )
	{
	  const Index  j = face[ i ];
	  const Index nj = face[ (i+1) % face.size() ];
	  n += ( myPositions[ j ] - p ).crossProduct( myPositions[ nj ] - p );
	}
      auto n_norm = n.norm();
      myFaceNormals[ f ] = n_norm != 0.0 ? n / n_norm : n;
      f++;
    }
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFaceNormalsFromVertexNormals()
{
  if ( myVertexNormals.empty() ) return;
  myFaceNormals.resize( myIncidentVertices.size() );
  Index f = 0;
  for ( auto face : myIncidentVertices )
    {
      RealVector n; // normal
      for ( auto idx : face ) n += myVertexNormals[ idx ];
      auto n_norm = n.norm();
      myFaceNormals[ f ] = n_norm != 0.0 ? n / n_norm : n;
      f++;
    }
}
//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeVertexNormalsFromFaceNormals()
{
  if ( myFaceNormals.empty() ) return;
  myVertexNormals.resize( myIncidentFaces.size() );
  Index v = 0;
  for ( auto vertex : myIncidentFaces )
    {
      RealVector n; // normal
      for ( auto idx : vertex ) n += myFaceNormals[ idx ];
      auto n_norm = n.norm();
      myVertexNormals[ v ] = n_norm != 0.0 ? n / n_norm : n;
      v++;
    }
}
//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeVertexNormalsFromFaceNormalsWithMaxWeights()
{
  if ( myFaceNormals.empty() ) return;
  myVertexNormals.resize( myIncidentFaces.size() );
  Index v = 0;
  for ( auto incident_faces : myIncidentFaces )
    {
      RealVector n; // normal
      const auto weights = getMaxWeights( v );
      Index i = 0;
      for ( auto idx_f : incident_faces ) n += weights[ i++ ] * myFaceNormals[ idx_f ];
      auto n_norm = n.norm();
      myVertexNormals[ v ] = n_norm != 0.0 ? n / n_norm : n;
      v++;
    }
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::Scalars
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
getMaxWeights( Index v ) const
{
  Scalars        weights;
  const auto & neighbors = myNeighborVertices[ v ];
  const RealPoint      x = myPositions[ v ]; 
  for ( auto idx_f : myIncidentFaces[ v ] )
    {
      // Find adjacent vertices to v
      std::vector< Index > adj_vertices;
      for ( auto idx_v : myIncidentVertices[ idx_f ] )
        {
          auto it = std::find( neighbors.cbegin(), neighbors.cend(), idx_v );
          if ( it != neighbors.cend() ) adj_vertices.push_back( *it );
        }
      if ( adj_vertices.size() != 2 )
        trace.warning() << "[SimplifiedMesh::getMaxWeights] "
                        << adj_vertices.size() << " adjacent vertices to vertex "
                        << v << " on face" << idx_f << "." << std::endl;
      if (adj_vertices.size() >= 2 )
        {
          const Scalar area = faceArea( idx_f );
          const Scalar   l1 = ( myPositions[ adj_vertices[ 0 ] ] - x ).squaredNorm();
          const Scalar   l2 = ( myPositions[ adj_vertices[ 1 ] ] - x ).squaredNorm();
          const Scalar l1l2 = l1 * l2;
          weights.push_back( l1l2 != 0 ? fabs( area ) / l1l2 : 0.0 );
        }
      else weights.push_back( 0.0 );
    }
  return weights;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename AnyRing>
std::vector<AnyRing> 
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFaceValuesFromVertexValues( const std::vector<AnyRing>& vvalues ) const
{
  ASSERT( vvalues.size() == nbVertices() );
  std::vector<AnyRing> fvalues( nbFaces() );
  Index f = 0;
  for ( auto face : myIncidentVertices )
    {
      AnyRing n = NumberTraits<AnyRing>::ZERO;
      for ( auto idx : face ) n += vvalues[ idx ];
      fvalues[ f++ ] = n / face.size();
    }
  return fvalues;
}
    
template <typename TRealPoint, typename TRealVector>
template <typename AnyRing>
std::vector<AnyRing> 
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeVertexValuesFromFaceValues( const std::vector<AnyRing>& fvalues ) const
{
  ASSERT( fvalues.size() == nbFaces() );
  std::vector<AnyRing> vvalues( nbVertices() );
  Index v = 0;
  for ( auto vertex : myIncidentFaces )
    {
      AnyRing n = NumberTraits<AnyRing>::ZERO;
      for ( auto idx : vertex ) n += fvalues[ idx ];
      vvalues[ v++ ] = n / vertex.size();
    }
  return vvalues;
}


//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::Edge 
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
makeEdge( Vertex i, Vertex j ) const
{
  VertexPair vp = i < j ? std::make_pair( i,j ) : std::make_pair( j,i );
  auto it = std::lower_bound( myEdgeVertices.cbegin(), myEdgeVertices.cend(), vp );
  if ( it == myEdgeVertices.cend() || *it != vp ) return nbEdges();
  return it - myEdgeVertices.cbegin();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::Scalar
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
averageEdgeLength() const
{
  double      lengths = 0.0;
  for ( Edge e = 0; e < nbEdges(); ++e )
    {
      auto vtcs = edgeVertices()[ e ];
      const RealPoint  p  = myPositions[ vtcs.first  ];
      const RealVector pq = myPositions[ vtcs.second ] - p;
      lengths += pq.norm();
    }
  lengths /= nbEdges();
  return lengths;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
perturbateWithUniformRandomNoise( Scalar p )
{
  for ( auto& x : myPositions )
    {
      RealVector d( rand01()*2.0 - 1.0, rand01()*2.0 - 1.0, rand01()*2.0 - 1.0 );
      d = d.getNormalized();
      Scalar l = rand01() * p;
      x += l * d;
    }
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::RealPoint
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
faceCentroid( Index f ) const
{
  RealPoint c;
  for ( auto v : myIncidentVertices[ f ] )
    c += myPositions[ v ];
  return c / myIncidentVertices[ f ].size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::Scalar
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
faceArea( Index f ) const
{
  Scalar area = 0.0;
  const auto & inc_vtcs = myIncidentVertices[ f ];
  RealPoint p = myPositions[ inc_vtcs.back() ];
  const Index m = inc_vtcs.size() - 2;
  for ( Index i = 0; i < m; ++i )
    area += ( myPositions[ inc_vtcs[ i ] ] - p )
      .crossProduct( myPositions[ inc_vtcs[ i+1 ] ] - p ).norm();
  return area / 2.0;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::WeightedFaces 
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeFacesInclusionsInBall( Scalar r, Index f ) const
{
  WeightedFaces result;
  if ( r < 0.000001 )
    {
      result.push_back( std::make_pair( f, 0.000001 ) );
      return result;
    }
  RealPoint p = faceCentroid( f );
  std::set< Index > marked;
  std::queue< Index > active;
  active.push( f );
  marked.insert( f );
  while ( ! active.empty() )
    {
      Index current = active.front();
      active.pop();
      Scalar weight = inclusionRatio( p, r, current );
      if ( weight > 0.0 )
	{
	  result.push_back( std::make_pair( current, weight ) );
	  auto neighbors = myNeighborFaces[ current ];
	  for ( auto n : neighbors )
	    if ( marked.find( n ) == marked.end() )
	      {
		active.push( n );
		marked.insert( n );
	      }
	}
    }
  // trace.info() << "#Marked=" << marked.size()
  // 	       << " #Result=" << result.size() << std::endl;
  return result;
}
//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::SimplifiedMesh<TRealPoint, TRealVector>::Scalar
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
inclusionRatio( RealPoint p, Scalar r, Index f ) const
{
  const auto vertices = myIncidentVertices[ f ];
  const RealPoint   b = faceCentroid( f );
  Scalar        d_min = ( b - p ).norm();
  Scalar        d_max = d_min;
  for ( auto v : vertices )
    {
      Scalar    d = ( myPositions[ v ] - p ).norm();
      d_max = std::max( d_max, d );
      d_min = std::min( d_min, d );
    }
  if      ( d_max <= r     ) return 1.0;
  else if ( r     <= d_min ) return 0.0;
  return ( r - d_min ) / ( d_max - d_min );
}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
selfDisplay ( std::ostream & out ) const
{
  out << "[SimplifiedMesh" << ( isValid() ? " (OK)" : " (KO)" )
      << " #V=" << myPositions.size()
      << " #VN=" << myVertexNormals.size()
      << " #E=" << myEdgeVertices.size()
      << " #F=" << myIncidentVertices.size()
      << " #FN=" << myFaceNormals.size();
  double nb_nf  = 0.0;
  double nb_nv  = 0.0;
  double nb_nfe = 0.0;
  for ( auto nf  : myNeighborFaces )    nb_nf  += nf.size();
  for ( auto nv  : myNeighborVertices ) nb_nv  += nv.size();
  for ( auto nfe : myEdgeFaces )        nb_nfe += nfe.size();
  nb_nf  /= nbFaces();
  nb_nv  /= nbVertices();
  nb_nfe /= nbEdges();
  out << " E[IF]=" << nb_nf << " E[IV]=" << nb_nv << " E[IFE]=" << nb_nfe;
  out << "]";
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
isValid() const
{
  return myPositions.size() == myIncidentFaces.size()
    && ( myVertexNormals.size() == 0
	 || ( myVertexNormals.size() == myPositions.size() ) )
    && ( myFaceNormals.size() == 0
	 || ( myFaceNormals.size() == myIncidentVertices.size() ) );
}


//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeNeighbors()
{
  myNeighborFaces   .resize( nbFaces() );
  myNeighborVertices.resize( nbVertices() );
  // For each face, computes its neighboring faces
  Index idx_f = 0;
  for ( auto incident_vertices : incidentVertices() )
    {
      std::set< Index > neighbor_faces_set;
      for ( auto idx_v : incident_vertices )
	{
	  const auto & incident_faces = incidentFaces()[ idx_v ];
	  neighbor_faces_set.insert( incident_faces.begin(), incident_faces.end() );
	}
      neighbor_faces_set.erase( idx_f );
      Faces neighbor_faces( neighbor_faces_set.begin(), neighbor_faces_set.end() );
      myNeighborFaces[ idx_f++ ] = neighbor_faces;
    }
  // For each vertex, computes its neighboring vertices
  Index idx_v = 0;
  for ( auto incident_faces : incidentFaces() )
    {
      std::set< Index > neighbor_vertices_set;
      for ( auto idx_f : incident_faces )
	{
	  const auto & incident_vertices = incidentVertices()[ idx_f ];
	  neighbor_vertices_set.insert( incident_vertices.begin(),
					incident_vertices.end() );
	}
      neighbor_vertices_set.erase( idx_v );
      Vertices neighbor_vertices( neighbor_vertices_set.begin(),
				  neighbor_vertices_set.end() );
      myNeighborVertices[ idx_v++ ] = neighbor_vertices;
    }
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
void
DGtal::SimplifiedMesh<TRealPoint, TRealVector>::
computeEdges()
{
  std::map< VertexPair, std::vector<Face> > edge2face;
  Index idx_f = 0;
  for ( auto incident_vertices : incidentVertices() )
    {
      const Size n = incident_vertices.size();
      for ( Size i = 0; i < n; i++ )
	{
	  VertexPair e = std::make_pair( incident_vertices[ i ],
					 incident_vertices[ (i+1) % n ] );
	  if ( e.second < e.first ) std::swap( e.first, e.second );
	  edge2face[ e ].push_back( idx_f );
	}
      idx_f++;
    }
  myEdgeVertices.resize( edge2face.size() );
  myEdgeFaces.resize( edge2face.size() );
  Index idx_e = 0;
  for ( auto e2f : edge2face )
    {
      myEdgeVertices[ idx_e ] = e2f.first;
      myEdgeFaces   [ idx_e ] = e2f.second;
      idx_e++;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
std::ostream&
DGtal::operator<< ( std::ostream & out, 
                    const SimplifiedMesh<TRealPoint, TRealVector> & object )
{
  object.selfDisplay( out );
  return out;
}


///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
verifyIndices( const std::vector< Index > indices )
{
  std::set<Index> sindices( indices.begin(), indices.end() );
  return sindices.size() == indices.size();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
std::vector< std::string > 
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
split( const std::string& str, char delim )
{
  std::stringstream ss(str);
  std::string token;
  std::vector< std::string > cont;
  while ( std::getline( ss, token, delim ) ) cont.push_back(token);
  return cont;
}    

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshReader<TRealPoint, TRealVector>::
readOBJ( std::istream & input, SimplifiedMesh & smesh )
{
  std::vector<RealPoint>  vertices;
  std::vector<RealVector> normals;
  std::vector< std::vector< Index > > faces;
  std::vector< std::vector< Index > > faces_normals_idx;
  std::string linestr;
  std::string keyword;
  std::string indices;
  RealPoint  p;
  RealVector n;
  std::getline( input, linestr );
  Index l = 0;
  for ( ; input.good() && ! input.eof(); std::getline( input, linestr ), l++ )
    {
      if ( linestr.empty() ) continue; // skip empty line
      if ( linestr[0] == '#' ) continue; // skip comment line
      std::istringstream lineinput( linestr );
      std::operator>>( lineinput, keyword ); // lineinput >> keyword;
      if ( keyword == "v" ) {
	lineinput >> p[ 0 ] >> p[ 1 ] >> p[ 2 ];
	// std::cout << "[" << l << "] v " << p << std::endl;
	vertices.push_back( p );
      } else if ( keyword == "vn" ) {
	lineinput >> n[ 0 ] >> n[ 1 ] >> n[ 2 ];
	normals.push_back( n );
      } else if ( keyword == "f" ) {
	std::vector< Index > face, face_normals;
	while ( ! lineinput.eof() ) {
          std::operator>>( lineinput, indices ); // lineinput >> indices;
	  if ( indices.empty() ) break;
	  auto vtxinfo = split( indices, '/' );
	  if ( vtxinfo.size() == 0 ) break;
	  Index v  = std::stoi( vtxinfo[ 0 ] );
	  Index vn = vtxinfo.size() >= 3 ? std::stoi( vtxinfo[ 2 ] ) : v;
	  face.push_back( v - 1 );
	  face_normals.push_back( vn - 1 );
	  indices = "";
	}
	if ( ! face.empty() && verifyIndices( face ) )
	  {
	    faces.push_back( face );
	    faces_normals_idx.push_back( face_normals );
	  }
      }
      // Weird: necessary to clear them.
      keyword = ""; linestr = "";
    } // while ( ! input.eof() )
  // Creating SimplifiedMesh
  trace.info() << "[SimplifiedMeshReader::readOBJ] Read"
	       << " #lines=" << l
	       << " #V=" << vertices.size()
	       << " #VN=" << normals.size()
	       << " #F=" << faces.size() << std::endl;
  if ( input.bad() )
    trace.warning() << "[SimplifiedMeshReader::readOBJ] Some I/O error occured."
		    << " Proceeding but the mesh may be damaged." << std::endl;
  bool ok = smesh.init( vertices.begin(), vertices.end(),
			faces.begin(), faces.end() );
  if ( ! ok )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error initializing mesh." << std::endl;
  if ( ( ! normals.empty() ) && ( normals.size() == vertices.size() ) )
    { // Build vertex normal map
      bool ok_vtx_normals = smesh.setVertexNormals( normals.begin(), normals.end() );
      if ( ! ok_vtx_normals )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error setting vertex normals." << std::endl;
      ok = ok && ok_vtx_normals;
    }
  if ( ! normals.empty() )
    { // Build face normal map
      std::vector< RealVector > faces_normals;
      Index i = 0;
      for ( auto face_n_indices : faces_normals_idx )
	{ 
	  RealVector n;
	  for ( auto k : face_n_indices ) n += normals[ k ];
	  n /= face_n_indices.size();
	  faces_normals.push_back( n );
	}
      bool ok_face_normals = smesh.setFaceNormals( faces_normals.begin(),
						   faces_normals.end() );
      if ( ! ok_face_normals )
	trace.warning() << "[SimplifiedMeshReader::readOBJ]"
			<< " Error setting face normals." << std::endl;
      ok = ok && ok_face_normals;
    }
  return ( ! input.bad() ) && ok;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshWriter<TRealPoint, TRealVector>::
writeOBJ( std::ostream & output, const SimplifiedMesh & smesh )
{
  output << "# OBJ format" << std::endl;
  output << "# DGtal::SimplifiedMeshWriter::writeOBJ" << std::endl;
  output << "o anObject" << std::endl;
  for ( auto v : smesh.positions() )
    output << "v " << v[ 0 ] << " " << v[ 1 ] << " " << v[ 2 ] << std::endl;
  output << "# " << smesh.positions().size() << " vertices" << std::endl;
  if ( ! smesh.vertexNormals().empty() )
    {
      for ( auto vn : smesh.vertexNormals() )
        output << "vn " << vn[ 0 ] << " " << vn[ 1 ] << " " << vn[ 2 ] << std::endl;
      output << "# " << smesh.vertexNormals().size() << " normal vectors" << std::endl;
    }
  for ( auto f : smesh.incidentVertices() )
    {
      output << "f";
      for ( auto v : f ) output << " " << (v+1);
      output << std::endl;
    }
  output << "# " << smesh.incidentVertices().size() << " faces" << std::endl;
  return output.good();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::SimplifiedMeshWriter<TRealPoint, TRealVector>::
writeOBJ( std::string            objfile,
          const SimplifiedMesh & smesh, 
          const Colors&          diffuse_colors,
          const Color&           ambient_color,
          const Color&           diffuse_color,
          const Color&           specular_color )
{
  std::string mtlfile;
  auto lastindex = objfile.find_last_of(".");
  if ( lastindex == std::string::npos )
    {
      mtlfile  = objfile + ".mtl";
      objfile  = objfile + ".obj";
    }
  else
    {
      mtlfile  = objfile.substr(0, lastindex) + ".mtl"; 
    }
  std::ofstream output_obj( objfile.c_str() );
  output_obj << "#  OBJ format" << std::endl;
  output_obj << "# DGtal::SimplifiedMeshWriter::writeOBJ" << std::endl;
  output_obj << "o anObject" << std::endl;
  // remove directory to write material
  auto indexpath = objfile.find_last_of("/");
  output_obj << "mtllib " << mtlfile.substr(indexpath+1) << std::endl;
  std::ofstream output_mtl( mtlfile.c_str() );
  output_mtl << "#  MTL format"<< std::endl;
  output_mtl << "# generated from SimplifiedMeshWriter from the DGTal library"<< std::endl;
  // Write positions
  for ( auto v : smesh.positions() )
    output_obj << "v " << v[ 0 ] << " " << v[ 1 ] << " " << v[ 2 ] << std::endl;
  output_obj << "# " << smesh.positions().size() << " vertices" << std::endl;
  // Write vertex normals
  if ( ! smesh.vertexNormals().empty() )
    {
      for ( auto vn : smesh.vertexNormals() )
        output_obj << "vn " << vn[ 0 ] << " " << vn[ 1 ] << " " << vn[ 2 ] << std::endl;
      output_obj << "# " << smesh.vertexNormals().size() << " normal vectors" << std::endl;
    }
  // Taking care of materials
  bool  has_material = ( smesh.nbFaces() == diffuse_colors.size() );
  Index idxMaterial = 0;
  std::map<Color, Index > mapMaterial;
  if ( has_material )
    {
      for ( Index f = 0; f < diffuse_colors.size(); ++f )
        {
          Color c = diffuse_colors[ f ];
          if ( mapMaterial.count( c ) == 0 )
            {
              MeshHelpers::exportMTLNewMaterial
                ( output_mtl, idxMaterial, ambient_color, c, specular_color );
              mapMaterial[ c ] = idxMaterial++;
            }
        }
    }
  else
    {
      MeshHelpers::exportMTLNewMaterial
        ( output_mtl, idxMaterial, ambient_color, diffuse_color, specular_color );
    }
  // Write faces with material(s)
  Index idx_f = 0;
  for ( auto f : smesh.incidentVertices() )
    {
      output_obj << "usemtl material_"
                 << ( has_material ? mapMaterial[ diffuse_colors[ idx_f ] ] : idxMaterial )
                 << std::endl; 
      output_obj << "f";
      for ( auto v : f )
        if ( smesh.vertexNormals().empty() )
          output_obj << " " << (v+1);
        else
          output_obj << " " << (v+1) << "//" << (v+1);
      output_obj << std::endl;
      idx_f++;
    }
  output_obj << "# " << smesh.incidentVertices().size() << " faces" << std::endl;
  output_mtl.close();
  return output_obj.good();
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
template <typename EdgePredicate>
bool
DGtal::SimplifiedMeshWriter<TRealPoint, TRealVector>::
writeEdgeLinesOBJ( std::string            objfile,
		   const SimplifiedMesh & smesh,
		   const EdgePredicate &  edge_predicate,
		   const double           relative_thickness,
		   const Color&           ambient_color,
		   const Color&           diffuse_color,
		   const Color&           specular_color )
{
  typedef KhalimskySpaceND< 3, int >    KSpace;
  typedef Shortcuts< KSpace >           SH;
  typedef typename SH::RealPoint        RealPoint;
  typedef typename SH::RealPoints       RealPoints;
  typedef typename SH::RealVector       RealVector;
  typedef typename SH::RealVectors      RealVectors;
  typedef typename SH::Colors           Colors;
  typedef typename SimplifiedMesh::Edge Edge;

  RealPoints  positions;
  RealVectors edge_vectors;
  double      lengths = 0.0;
  for ( Edge e = 0; e < smesh.nbEdges(); ++e )
    {
      auto vtcs = smesh.edgeVertices()[ e ];
      const RealPoint  p  = smesh.positions()[ vtcs.first  ];
      const RealVector pq = smesh.positions()[ vtcs.second ] - p;
      lengths += pq.norm();
      if ( ! edge_predicate( e ) ) continue;
      positions.push_back( p );
      edge_vectors.push_back( pq );
    }
  lengths /= smesh.nbEdges();
  return SH::saveVectorFieldOBJ
    ( positions, edge_vectors, lengths*relative_thickness,
      Colors(), objfile, ambient_color, diffuse_color, specular_color );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
