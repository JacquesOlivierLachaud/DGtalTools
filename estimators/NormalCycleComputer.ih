/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file NormalCycleComputer.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2020/02/18
 *
 * Implementation of inline methods defined in NormalCycleComputer.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
NormalCycleComputer( ConstAlias< SimplifiedMesh > aMesh )
  : myMesh( aMesh )
{}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
computeMeasures( Measure mu, bool unit_u )
{
  if ( myMesh.vertexNormals().empty() )
    {
      trace.warning() << "[NormalCycleComputer::computeMeasures]"
                      << " Unable to compute measures without vertex normals." << std::endl;
      return false;
    }
  if ( mu == Measure::ALL_MU || mu == Measure::MU0  ) computeMu0 ( unit_u );
  if ( mu == Measure::ALL_MU || mu == Measure::MU1  ) computeMu1 ( unit_u );
  if ( mu == Measure::ALL_MU || mu == Measure::MU2  ) computeMu2 ( unit_u );
  if ( mu == Measure::ALL_MU || mu == Measure::MUXY ) computeMuXY( unit_u );
  return true;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
computeMu0( bool unit_u )
{
  if ( myMesh.vertexNormals().empty() )
    {
      trace.warning() << "[NormalCycleComputer::computeMu0]"
                      << " Unable to compute measures without vertex normals." << std::endl;
      return false;
    }
  mu0.resize( myMesh.nbFaces() );
  Index idx_f = 0;
  for ( auto f : myMesh.incidentVertices() )
    {
      RealPoints  p( f.size() );
      RealVectors u( f.size() );
      for ( Index idx_v = 0; idx_v < f.size(); ++idx_v )
        {
          p[ idx_v ] = myMesh.positions()    [ f[ idx_v ] ];
          u[ idx_v ] = myMesh.vertexNormals()[ f[ idx_v ] ];
        }
      mu0[ idx_f++ ] = Formula::mu0U( p, u, unit_u );
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
computeMu1( bool unit_u )
{
  if ( myMesh.vertexNormals().empty() )
    {
      trace.warning() << "[NormalCycleComputer::computeMu1]"
                      << " Unable to compute measures without vertex normals." << std::endl;
      return false;
    }
  mu1.resize( myMesh.nbFaces() );
  Index idx_f = 0;
  for ( auto f : myMesh.incidentVertices() )
    {
      RealPoints  p( f.size() );
      RealVectors u( f.size() );
      for ( Index idx_v = 0; idx_v < f.size(); ++idx_v )
        {
          p[ idx_v ] = myMesh.positions()    [ f[ idx_v ] ];
          u[ idx_v ] = myMesh.vertexNormals()[ f[ idx_v ] ];
        }
      mu1[ idx_f++ ] = Formula::mu1U( p, u, unit_u );
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
computeMu2( bool unit_u )
{
  if ( myMesh.vertexNormals().empty() )
    {
      trace.warning() << "[NormalCycleComputer::computeMu2]"
                      << " Unable to compute measures without vertex normals." << std::endl;
      return false;
    }
  mu2.resize( myMesh.nbFaces() );
  Index idx_f = 0;
  for ( auto f : myMesh.incidentVertices() )
    {
      RealPoints  p( f.size() );
      RealVectors u( f.size() );
      for ( Index idx_v = 0; idx_v < f.size(); ++idx_v )
        {
          p[ idx_v ] = myMesh.positions()    [ f[ idx_v ] ];
          u[ idx_v ] = myMesh.vertexNormals()[ f[ idx_v ] ];
        }
      mu2[ idx_f ] = Formula::mu2U( p, u, unit_u );
      // if ( isnan( mu2[ idx_f ] ) )
      //   {
      //     trace.warning() << "At face " << idx_f
      //                     << ", with " << f.size() << " inc. vtx,"
      //                     << " mu2 not a number." << std::endl;
      //     for ( auto x : p ) trace.warning() << "x=" << x << std::endl;
      //     for ( auto n : u ) trace.warning() << "n=" << n << std::endl;
      //   }
      idx_f++;
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
bool
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
computeMuXY( bool unit_u )
{
  if ( myMesh.vertexNormals().empty() )
    {
      trace.warning() << "[NormalCycleComputer::computeMuXY]"
                      << " Unable to compute measures without vertex normals." << std::endl;
      return false;
    }
  muXY.resize( myMesh.nbFaces() );
  Index idx_f = 0;
  for ( auto f : myMesh.incidentVertices() )
    {
      RealPoints  p( f.size() );
      RealVectors u( f.size() );
      for ( Index idx_v = 0; idx_v < f.size(); ++idx_v )
        {
          p[ idx_v ] = myMesh.positions()    [ f[ idx_v ] ];
          u[ idx_v ] = myMesh.vertexNormals()[ f[ idx_v ] ];
        }
      muXY[ idx_f++ ] = Formula::muXYU( p, u, unit_u );
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::NormalCycleComputer<TRealPoint, TRealVector>::Scalar
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
Mu0 ( const WeightedFaces& wfaces ) const
{
  Scalar m = 0.0;
  for ( auto wf : wfaces )  m += wf.second * mu0[ wf.first ];
  return m;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::NormalCycleComputer<TRealPoint, TRealVector>::Scalar
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
Mu1 ( const WeightedFaces& wfaces ) const
{
  Scalar m = 0.0;
  for ( auto wf : wfaces )  m += wf.second * mu1[ wf.first ];
  return m;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::NormalCycleComputer<TRealPoint, TRealVector>::Scalar
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
Mu2 ( const WeightedFaces& wfaces ) const
{
  Scalar m = 0.0;
  for ( auto wf : wfaces )  m += wf.second * mu2[ wf.first ];
  return m;
}

//-----------------------------------------------------------------------------
template <typename TRealPoint, typename TRealVector>
typename DGtal::NormalCycleComputer<TRealPoint, TRealVector>::RealTensor
DGtal::NormalCycleComputer<TRealPoint, TRealVector>::
MuXY( const WeightedFaces& wfaces ) const
{
  RealTensor m = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
  for ( auto wf : wfaces )  m += wf.second * muXY[ wf.first ];
  return m;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
